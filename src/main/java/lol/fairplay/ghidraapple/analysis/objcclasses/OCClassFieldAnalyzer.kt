package lol.fairplay.ghidraapple.analysis.objcclasses

import ghidra.app.services.AbstractAnalyzer
import ghidra.app.services.AnalysisPriority
import ghidra.app.services.AnalyzerType
import ghidra.app.util.importer.MessageLog
import ghidra.program.model.address.AddressSetView
import ghidra.program.model.address.GenericAddress
import ghidra.program.model.data.*
import ghidra.program.model.listing.Data
import ghidra.program.model.listing.Program
import ghidra.program.model.scalar.Scalar
import ghidra.program.model.symbol.Symbol
import ghidra.util.task.TaskMonitor
import lol.fairplay.ghidraapple.analysis.utilities.tryResolveNamespace

private data class IVarField(val name: String, val type: String, val size: Int, val offset: Int)
private data class IVarFieldList(val classSymbol: Symbol, val ivars: List<IVarField>)

class OCClassFieldAnalyzer : AbstractAnalyzer(NAME, DESCRIPTION, AnalyzerType.DATA_ANALYZER) {

    lateinit var program: Program
    lateinit var log: MessageLog

    companion object {
        const val NAME = "Objective-C Class Field Analyzer"
        const val DESCRIPTION = "Creates field entries in class structures generated by the \"Objective-C Structures\" pass."
        val PRIORITY = AnalysisPriority.DATA_ANALYSIS
    }

    init {
        priority = PRIORITY
        setPrototype()
        setSupportsOneTimeAnalysis()
    }

    override fun canAnalyze(program: Program): Boolean {
        this.program = program

        val objcConstSection = program.memory.getBlock("__objc_const")
        return objcConstSection != null
    }

    override fun added(program: Program, set: AddressSetView, monitor: TaskMonitor, log: MessageLog): Boolean {
        this.log = log
        val typeResolver = TypeResolver(program)
        val idDataType = program.dataTypeManager.getDataType("/_objc2_/ID")
        val fieldLists = getIVarListsInAddressSet(set, monitor) ?: return false

        program.withTransaction<Exception>("Change __objc_const section permissions.") {
            val objcConstSection = program.memory.getBlock("__objc_const")
            objcConstSection.setPermissions(true, false, false)
        }

        monitor.message = "Applying class structure fields..."
        monitor.progress = 0
        monitor.maximum = fieldLists.size.toLong()

        program.withTransaction<Exception>("Apply fields.") {
            for (it in fieldLists) {
                monitor.checkCancelled()
                val definedClassStruct = typeResolver.tryResolveDefinedStruct(it.classSymbol.name) as Structure?
                if (definedClassStruct == null) {
                    log.appendMsg("Couldn't find defined structure for ${it.classSymbol.name} ivar list.")
                    continue
                }

                it.ivars.forEach { field ->

                    val fieldSize = field.size.toInt()


                    val fieldType = field.type.let { typeString ->
                        val resolvedType = typeResolver.parseEncoded(typeString)

                        if (resolvedType == null ){
                            Undefined.getUndefinedDataType(fieldSize)
                        }
                        // There is some bug where a field is typed as int with size 4, but Ghidra later
                        // treats an int as size 8, and then fails to decompile functions using this field
                        // to fix this we change them to short and unsigned short respectively.
                        else if (resolvedType.name == "int" && fieldSize == 4) {
                            ShortDataType.dataType
                        }
                        else if (resolvedType.name == "uint" && fieldSize == 8) {
                            UnsignedShortDataType.dataType
                        }
                        else {
                            resolvedType
                        }
                    }

                    definedClassStruct.insertAtOffset(field.offset, fieldType, fieldSize, field.name, null)
                }

                monitor.incrementProgress()
            }
        }

        return true
    }

    private fun getIVarListsInAddressSet(set: AddressSetView, monitor: TaskMonitor?): List<IVarFieldList>? {

        monitor?.message = "Parsing ivar list structures..."

        val ivarNamespace = tryResolveNamespace(program, "objc", "ivar_list_t") ?: return null

        val ivarNamespaceName = ivarNamespace.getName(true)

        var ivarLists = program.listing.getDefinedData(set, true)
            .filter { data ->
                val primarySymbol = data.primarySymbol
                val parentNamespace = primarySymbol?.parentNamespace
                primarySymbol != null &&
                        parentNamespace != null &&
                        parentNamespace.getName(true) == ivarNamespaceName
            }

        monitor?.maximum = ivarLists.size.toLong()
        monitor?.progress = 0

        val parsedLists = ivarLists.mapNotNull { data ->
            val result = parseIVarFieldList(data)
            monitor?.incrementProgress()
            result
        }.toList()

        return if (parsedLists.isNotEmpty()) parsedLists else null
    }

    private fun parseIVarFieldList(data: Data): IVarFieldList? {
        val definedClassStruct = data.primarySymbol
        val ivFields = mutableListOf<IVarField>()

        if (data.numComponents <= 2)
            return null

        for (i in 2 until data.numComponents) {

            // struct ivar_t {
            //    Off  Type      Len Name
            //    0    qword*    8   offset      ""
            //    8    string*   8   name        ""
            //    16   string*   8   type        ""
            //    24   dword     4   alignment   ""
            //    28   dword     4   size        ""
            // }

            if (data.getComponent(i).dataType.name != "ivar_t")
                continue

            val fields = (0..<data.getComponent(i).numComponents).map {
                data.getComponent(i).getComponent(it)
            }

            // There's gotta be a better way to do this...
            val ivfName = program.listing.getDataAt(fields[1].value as GenericAddress?).value as String
            val ivfType = program.listing.getDataAt(fields[2].value as GenericAddress?).value as String
            val ivfSize = (fields[4].value as Scalar).unsignedValue.toInt()
            val ivfOffset = (program.listing.getDataAt((fields[0].value as GenericAddress)).value as Scalar).unsignedValue.toInt()

            ivFields.add(IVarField(ivfName, ivfType, ivfSize, ivfOffset))
        }

        return IVarFieldList(definedClassStruct, ivFields)
    }
}
