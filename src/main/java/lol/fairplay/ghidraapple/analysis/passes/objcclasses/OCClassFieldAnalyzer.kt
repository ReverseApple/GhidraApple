package lol.fairplay.ghidraapple.analysis.passes.objcclasses

import ghidra.app.services.AbstractAnalyzer
import ghidra.app.services.AnalysisPriority
import ghidra.app.services.AnalyzerType
import ghidra.app.util.importer.MessageLog
import ghidra.program.model.address.AddressSetView
import ghidra.program.model.address.GenericAddress
import ghidra.program.model.data.DataType
import ghidra.program.model.data.Structure
import ghidra.program.model.listing.Data
import ghidra.program.model.listing.Program
import ghidra.program.model.scalar.Scalar
import ghidra.program.model.symbol.Symbol
import ghidra.util.task.TaskMonitor
import lol.fairplay.ghidraapple.analysis.objectivec.GhidraTypeBuilder
import lol.fairplay.ghidraapple.analysis.objectivec.TypeResolver
import lol.fairplay.ghidraapple.analysis.utilities.tryResolveNamespace
import lol.fairplay.ghidraapple.core.objc.encodings.EncodingLexer
import lol.fairplay.ghidraapple.core.objc.encodings.TypeEncodingParser

private data class IVarField(val name: String, val type: String, val size: Int, val offset: Int)
private data class IVarFieldList(val classSymbol: Symbol, val ivars: List<IVarField>)

@Deprecated("Deprecated in favor of OCStructureAnalyzer")
class OCClassFieldAnalyzer : AbstractAnalyzer(NAME, DESCRIPTION, AnalyzerType.DATA_ANALYZER) {

    lateinit var program: Program
    lateinit var log: MessageLog

    companion object {
        const val NAME = "Objective-C Class Field Analyzer (Deprecated)"
        const val DESCRIPTION = "Creates field entries in class structures generated by the \"Objective-C Structures\" pass."
        val PRIORITY = AnalysisPriority.DATA_ANALYSIS
    }

    init {
        priority = PRIORITY
        setPrototype()
        setSupportsOneTimeAnalysis()
    }

    override fun canAnalyze(program: Program): Boolean {
        this.program = program

        val objcConstSection = program.memory.getBlock("__objc_const")
//        return objcConstSection != null
        return false
    }

    override fun added(program: Program, set: AddressSetView, monitor: TaskMonitor, log: MessageLog): Boolean {
        this.log = log
        val typeResolver = TypeResolver(program)
        val idDataType = program.dataTypeManager.getDataType("/_objc2_/ID")
        val fieldLists = getIVarListsInAddressSet(set, monitor) ?: return false

        monitor.message = "Applying class structure fields..."
        monitor.progress = 0
        monitor.maximum = fieldLists.size.toLong()

        program.withTransaction<Exception>("Apply fields.") {
            for (it in fieldLists) {
                val definedClassStruct = typeResolver.tryResolveDefinedStruct(it.classSymbol.name) as Structure?
                if (definedClassStruct == null) {
                    log.appendMsg("Couldn't find defined structure for ${it.classSymbol.name} ivar list.")
                    continue
                }

                for (field in it.ivars) {
                    var fieldType: DataType? = null
                    try {
                        println("Encoded: ${field.type}")
                        fieldType = getTypeFromEncoding(field.type)
                    } catch (e: Exception) {
                        log.appendMsg("Failed to resolve type: ${field.type}")
                        continue
                    }

                    println("${field.name}: ${fieldType.name}")

                    val fieldSize = field.size.toInt()

                    definedClassStruct.insertAtOffset(field.offset, fieldType, fieldSize, field.name, null)
                }

                monitor.incrementProgress()
            }
        }

        program.withTransaction<Exception>("Change __objc_const section permissions.") {
            val objcConstSection = program.memory.getBlock("__objc_const")
            objcConstSection.setPermissions(true, false, false)
        }

        return true
    }

    private fun getTypeFromEncoding(encoded: String): DataType {
        val lexer = EncodingLexer(encoded)
        val parser = TypeEncodingParser(lexer)

        val root = parser.parse()
        val builder = GhidraTypeBuilder(program)
        root.accept(builder)

        return builder.getResult()
    }

    private fun getIVarListsInAddressSet(set: AddressSetView, monitor: TaskMonitor?): List<IVarFieldList>? {

        monitor?.message = "Parsing ivar list structures..."

        val ivarNamespace = tryResolveNamespace(program, "objc", "ivar_list_t") ?: return null

        val ivarNamespaceName = ivarNamespace.getName(true)

        var ivarLists = program.listing.getDefinedData(set, true)
            .filter { data ->
                val primarySymbol = data.primarySymbol
                val parentNamespace = primarySymbol?.parentNamespace
                primarySymbol != null &&
                        parentNamespace != null &&
                        parentNamespace.getName(true) == ivarNamespaceName
            }

        monitor?.maximum = ivarLists.size.toLong()
        monitor?.progress = 0

        val parsedLists = ivarLists.mapNotNull { data ->
            val result = parseIVarFieldList(data)
            monitor?.incrementProgress()
            result
        }.toList()

        return if (parsedLists.isNotEmpty()) parsedLists else null
    }

    private fun parseIVarFieldList(data: Data): IVarFieldList? {
        val definedClassStruct = data.primarySymbol
        val ivFields = mutableListOf<IVarField>()

        if (data.numComponents <= 2)
            return null

        for (i in 2 until data.numComponents) {

            // struct ivar_t {
            //    Off  Type      Len Name
            //    0    qword*    8   offset      ""
            //    8    string*   8   name        ""
            //    16   string*   8   type        ""
            //    24   dword     4   alignment   ""
            //    28   dword     4   size        ""
            // }

            if (data.getComponent(i).dataType.name != "ivar_t")
                continue

            val fields = (0..<data.getComponent(i).numComponents).map {
                data.getComponent(i).getComponent(it)
            }

            // There's gotta be a better way to do this...
            val ivfName = program.listing.getDataAt(fields[1].value as GenericAddress?).value as String
            val ivfType = program.listing.getDataAt(fields[2].value as GenericAddress?).value as String
            val ivfSize = (fields[4].value as Scalar).unsignedValue.toInt()
            val ivfOffset = (program.listing.getDataAt((fields[0].value as GenericAddress)).value as Scalar).unsignedValue.toInt()

            ivFields.add(IVarField(ivfName, ivfType, ivfSize, ivfOffset))
        }

        return IVarFieldList(definedClassStruct, ivFields)
    }
}
